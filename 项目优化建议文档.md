# AI角色扮演系统 - 架构优化建议文档

本文档旨在对现有AI角色扮演项目的架构进行分析，并针对可维护性、可扩展性、安全性和开发效率等方面提出一系列优化建议。每个建议点都包含**原设计分析**、**改进设计目标**和**具体技术方案**三个部分。

---

## 目录
1.  [完善用户认证系统](#2-完善用户认证系统)
2.  [后端服务异步处理](#3-后端服务异步处理)
3.  [数据库版本管理](#4-数据库版本管理)
4.  [配置与密钥管理](#5-配置与密钥管理)
5.  [应用容器化部署](#6-应用容器化部署)

---



## 2. 完善用户认证系统

### 2.1 原设计分析
- **现状**: 根据`README`文档，用户认证系统已简化，尚未完全实现。API接口处于可公开访问状态，缺乏安全性。

### 2.2 改进设计目标
- **实现完整的JWT认证**: 用户通过账号密码登录，获取一个有时效性的Token。
- **API权限控制**: 后端通过验证请求头中的Token来识别用户身份，并保护需要授权的API接口。
- **前后端分离**: 前端负责存储和在请求中携带Token，后端负责签发和校验Token。

### 2.3 具体技术方案
1.  **后端 (Spring Boot)**:
    - **添加依赖**: 在`pom.xml`中添加JWT库。
      ```xml
      <dependency>
          <groupId>io.jsonwebtoken</groupId>
          <artifactId>jjwt-api</artifactId>
          <version>0.11.5</version>
      </dependency>
      <dependency>
          <groupId>io.jsonwebtoken</groupId>
          <artifactId>jjwt-impl</artifactId>
          <version>0.11.5</version>
          <scope>runtime</scope>
      </dependency>
      <dependency>
          <groupId>io.jsonwebtoken</groupId>
          <artifactId>jjwt-jackson</artifactId>
          <version>0.11.5</version>
          <scope>runtime</scope>
      </dependency>
      ```
    - **创建`JwtUtil`工具类**: 用于生成、解析和验证Token。
    - **修改`SecurityConfig`**:
        - 配置密码编码器（`BCryptPasswordEncoder`）。
        - 配置哪些路径需要认证，哪些路径（如`/api/users/login`）可以匿名访问。
        - 添加一个自定义的`JwtAuthenticationFilter`。
    - **实现`JwtAuthenticationFilter`**:
        - 该过滤器在每个请求到达Controller前执行。
        - 从请求的`Authorization`头中提取Token。
        - 使用`JwtUtil`验证Token的有效性。
        - 如果验证通过，从中解析出用户信息，并设置到Spring Security的`SecurityContextHolder`中。
    - **修改登录接口**: 登录成功后，调用`JwtUtil`生成Token并返回给前端。

2.  **前端 (Vue)**:
    - **存储Token**: 用户登录成功后，将后端返回的Token存储在`localStorage`或`sessionStorage`中。
    - **自动携带Token**: 创建一个`axios`的请求拦截器，在每个发出的请求头中自动添加`Authorization: Bearer <token>`。
      ```typescript
      // 在apiClient中配置拦截器
      apiClient.interceptors.request.use(config => {
        const userStore = useUserStore(); // 获取Pinia store
        if (userStore.token) {
          config.headers.Authorization = `Bearer ${userStore.token}`;
        }
        return config;
      });
      ```

---

## 3. 后端服务异步处理

### 3.1 原设计分析
- **现状**: 调用智谱AI这类第三方服务的API是同步执行的。如果AI模型响应慢，会导致API长时间阻塞，用户需要一直等待。
- **缺点**: 响应时间不可控，吞吐量低，用户体验差。

### 3.2 改进设计目标
- **提升响应速度**: 对于耗时操作（AI对话、语音合成），立即响应客户端，告知任务已开始处理。
- **提高系统吞吐量**: 通过异步执行，释放HTTP线程，使其可以处理更多其他请求。

### 3.3 具体技术方案
- **方案A (简单实现): Spring `@Async`**
    1.  **开启异步支持**: 在任一`@Configuration`类上添加`@EnableAsync`注解。
    2.  **改造服务方法**: 在`ZhipuAiService`或`SpeechService`中的耗时方法上添加`@Async`注解，并使其返回`CompletableFuture<T>`。
        ```java
        @Service
        public class ZhipuAiService {
            @Async
            public CompletableFuture<String> getChatCompletionAsync(String prompt) {
                // ... 调用AI模型的逻辑 ...
                String result = // ... 获取结果
                return CompletableFuture.completedFuture(result);
            }
        }
        ```
    3.  **改造Controller**: Controller调用异步方法，并通过`CompletableFuture`处理最终结果。

- **方案B (生产级): 消息队列 (RabbitMQ)**
    1.  **引入依赖**: `spring-boot-starter-amqp`。
    2.  **处理流程**:
        - `ConversationController`接收到`/chat`请求后，不再直接调用AI服务。
        - 而是将对话请求（如用户ID、角色ID、内容）封装成一个消息，发送到RabbitMQ的特定队列（如`chat.request.queue`）。
        - Controller立即返回一个任务ID或接受状态给前端。
    3.  **创建消费者**:
        - 一个独立的`@Service`（如`ChatConsumerService`）使用`@RabbitListener`注解监听`chat.request.queue`队列。
        - 收到消息后，执行调用智谱AI的耗时操作。
        - 处理完成后，可以通过WebSocket将结果实时推送给前端，或将结果存入数据库/Redis，由前端轮询获取。

---

## 4. 数据库版本管理

### 4.1 原设计分析
- **现状**: 数据库结构通过`schema.sql`和`data.sql`手动管理。
- **缺点**:
    - **协作困难**: 多人开发时，手动同步数据库变更非常容易出错。
    - **部署繁琐**: 每次部署都需要确认数据库结构是否为最新，容易遗漏。
    - **无法回滚**: 没有版本记录，一旦出错难以安全回滚。

### 4.2 改进设计目标
- **自动化迁移**: 使用`Flyway`或`Liquibase`工具，实现数据库变更的自动化和版本化管理。
- **提升可靠性**: 每次应用启动时，工具会自动检查数据库版本，并应用新的变更脚本，确保数据库结构与代码版本一致。

### 4.3 具体技术方案
1.  **引入Flyway依赖**: 在`pom.xml`中添加。
    ```xml
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-mysql</artifactId>
    </dependency>
    ```
2.  **移除旧配置**: 在`application.yml`中删除或注释掉`spring.sql.init.mode`相关配置。
3.  **创建迁移脚本**:
    - 在`src/main/resources/`下创建`db/migration`目录。
    - 将`schema.sql`的内容移动到一个新文件`V1__Create_initial_tables.sql`中。
    - 将`data.sql`的内容移动到一个新文件`V2__Insert_initial_data.sql`中。
    - **命名规则**: `V<版本号>__<描述>.sql` (版本号用整数，双下划线分隔)。
4.  **启动应用**: Flyway会自动生效。它会在数据库中创建一张`flyway_schema_history`表来记录已执行的迁移版本。之后每次启动，它只会执行比记录中版本号更新的脚本。

---

## 5. 配置与密钥管理

### 5.1 原设计分析
- **现状**: 智谱AI的`api-key`等敏感信息直接硬编码在`application.yml`文件中。
- **缺点**:
    - **安全风险**: 将密钥提交到Git仓库中，有泄露风险。
    - **灵活性差**: 在不同环境（开发、测试、生产）切换时，需要手动修改配置文件。

### 5.2 改进设计目标
- **外部化配置**: 将敏感信息从代码库中分离。
- **环境感知**: 应用能够根据不同的运行环境加载对应的配置。

### 5.3 具体技术方案
1.  **使用环境变量**: 这是最简单且通用的方法。
    - **修改`application.yml`**:
      ```yaml
      ai:
        zhipu:
          # 使用${ENV_VAR:default_value}语法
          api-key: ${ZHIPU_API_KEY:your_default_dev_key}
      ```
    - **运行时注入**:
        - **命令行**: `ZHIPU_API_KEY="your-real-key" mvn spring-boot:run`
        - **IDE (IntelliJ)**: 在"Run/Debug Configurations"中设置"Environment variables"。
        - **Docker**: 在`docker-compose.yml`或`Dockerfile`中设置环境变量。

2.  **Spring Profiles (多环境配置)**:
    - 创建多个配置文件，如`application-dev.yml`（开发）、`application-prod.yml`（生产）。
    - 在`application-prod.yml`中使用环境变量引用密钥。
    - 启动时通过`--spring.profiles.active=prod`来指定加载哪个配置文件。

---

## 6. 应用容器化部署

### 6.1 原设计分析
- **现状**: 项目部署依赖手动操作：在服务器上安装Java、Maven、MySQL、Redis环境，然后分别打包和启动前后端服务。
- **缺点**: 部署流程复杂、耗时、易出错，且难以保证开发、测试、生产环境的一致性。

### 6.2 改进设计目标
- **一键部署**: 使用Docker和Docker Compose，将整个应用（前后端、数据库、缓存）打包，实现一键启动。
- **环境一致性**: 保证在任何安装了Docker的机器上，应用都能以完全相同的方式运行。
- **简化运维**: 方便应用的迁移、扩展和管理。

### 6.3 具体技术方案
1.  **为后端创建`Dockerfile`**:
    ```dockerfile
    # Stage 1: Build the application
    FROM maven:3.8.5-openjdk-17 AS build
    WORKDIR /app
    COPY pom.xml .
    COPY src ./src
    RUN mvn clean package -DskipTests

    # Stage 2: Create the final image
    FROM openjdk:17-jdk-slim
    WORKDIR /app
    COPY --from=build /app/target/*.jar app.jar
    EXPOSE 8080
    ENTRYPOINT ["java", "-jar", "app.jar"]
    ```

2.  **为前端创建`Dockerfile` (基于Nginx)**:
    ```dockerfile
    # Stage 1: Build the Vue app
    FROM node:18 AS build
    WORKDIR /app
    COPY package*.json ./
    RUN npm install
    COPY . .
    RUN npm run build

    # Stage 2: Serve with Nginx
    FROM nginx:stable-alpine
    COPY --from=build /app/dist /usr/share/nginx/html
    # 可选: 复制一个自定义的nginx.conf来处理API代理
    EXPOSE 80
    CMD ["nginx", "-g", "daemon off;"]
    ```

3.  **创建`docker-compose.yml`编排所有服务**:
    ```yaml
    version: '3.8'
    services:
      backend:
        build: ./ai-roleplay-backend
        ports:
          - "8080:8080"
        environment:
          - SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/ai_roleplay?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
          - SPRING_REDIS_HOST=redis
          - ZHIPU_API_KEY=${ZHIPU_API_KEY} # 从.env文件或外部注入
        depends_on:
          - db
          - redis

      frontend:
        build: ./ai-roleplay-frontend-v2
        ports:
          - "3000:80"
        depends_on:
          - backend

      db:
        image: mysql:8.0
        environment:
          - MYSQL_ROOT_PASSWORD=root
          - MYSQL_DATABASE=ai_roleplay
        volumes:
          - mysql_data:/var/lib/mysql

      redis:
        image: redis:6.2-alpine

    volumes:
      mysql_data:
    ```
4.  **启动**: 在项目根目录下运行`docker-compose up --build`，即可一键启动整个应用。
